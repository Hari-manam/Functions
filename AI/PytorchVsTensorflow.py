# -*- coding: utf-8 -*-
"""PytorchVsTensorflow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pik1PEkeUaDsHUqC8qu4QIvGP5HBBn64
"""

from google.colab import files
uploaded = files.upload()  # Upload the `cats_and_dogs_filtered.zip` again

import zipfile

with zipfile.ZipFile("cats_and_dogs_filtered.zip", 'r') as zip_ref:
    zip_ref.extractall(".")

import os
import pandas as pd

# Step 1: Define path
extract_path = 'cats_and_dogs_filtered/train'
image_paths = []
labels = []

# Step 2: Loop through cats and dogs
for label_dir in ['cats', 'dogs']:
    full_dir = os.path.join(extract_path, label_dir)
    for filename in os.listdir(full_dir):
        if filename.endswith('.jpg'):
            image_paths.append(os.path.join(full_dir, filename))
            labels.append(label_dir)

# Step 3: Save to CSV
df = pd.DataFrame({'filename': image_paths, 'label': labels})
df.to_csv("cats_and_dogs_labels.csv", index=False)
df.head()

import pandas as pd
import os
import tensorflow as tf
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from PIL import Image

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import transforms
from torch.utils.data import Dataset, DataLoader
df = pd.read_csv("cats_and_dogs_labels.csv")
df['label'] = df['label'].map({'cats': 0, 'dogs': 1})
train_df, val_df = train_test_split(df, test_size=0.2, stratify=df['label'], random_state=42)

IMG_SIZE = (150, 150)

def load_image_tf(path, label):
    img = tf.io.read_file(path)
    img = tf.image.decode_jpeg(img, channels=3)
    img = tf.image.resize(img, IMG_SIZE)
    img = img / 255.0
    return img, label

train_ds_tf = tf.data.Dataset.from_tensor_slices((train_df['filename'].values, train_df['label'].values))
train_ds_tf = train_ds_tf.map(load_image_tf).shuffle(1000).batch(32).prefetch(tf.data.AUTOTUNE)

val_ds_tf = tf.data.Dataset.from_tensor_slices((val_df['filename'].values, val_df['label'].values))
val_ds_tf = val_ds_tf.map(load_image_tf).batch(32).prefetch(tf.data.AUTOTUNE)

model_tf = tf.keras.Sequential([
    tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2, 2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(128, activation='relu'),
    tf.keras.layers.Dense(1, activation='sigmoid')
])

model_tf.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
history_tf = model_tf.fit(train_ds_tf, validation_data=val_ds_tf, epochs=3)

plt.plot(history_tf.history['accuracy'], label='TF Train Acc')
plt.plot(history_tf.history['val_accuracy'], label='TF Val Acc')
plt.legend()
plt.title("TensorFlow Accuracy")
plt.show()

class CatDogDataset(Dataset):
    def __init__(self, df, transform=None):
        self.df = df.reset_index(drop=True)
        self.transform = transform

    def __len__(self):
        return len(self.df)

    def __getitem__(self, idx):
        path = self.df.loc[idx, 'filename']
        label = self.df.loc[idx, 'label']
        image = Image.open(path).convert("RGB")
        if self.transform:
            image = self.transform(image)
        return image, torch.tensor(label, dtype=torch.float32)

transform = transforms.Compose([
    transforms.Resize(IMG_SIZE),
    transforms.ToTensor()
])

train_ds_pt = CatDogDataset(train_df, transform)
val_ds_pt = CatDogDataset(val_df, transform)

train_loader = DataLoader(train_ds_pt, batch_size=32, shuffle=True)
val_loader = DataLoader(val_ds_pt, batch_size=32)

class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.model = nn.Sequential(
            nn.Conv2d(3, 32, 3), nn.ReLU(), nn.MaxPool2d(2),
            nn.Conv2d(32, 64, 3), nn.ReLU(), nn.MaxPool2d(2),
            nn.Flatten(),
            nn.Linear(64 * 36 * 36, 128), nn.ReLU(),
            nn.Linear(128, 1), nn.Sigmoid()
        )

    def forward(self, x):
        return self.model(x)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model_pt = SimpleCNN().to(device)
criterion = nn.BCELoss()
optimizer = optim.Adam(model_pt.parameters(), lr=0.001)

# Training loop
for epoch in range(3):
    model_pt.train()
    total_loss = 0
    for images, labels in train_loader:
        images, labels = images.to(device), labels.to(device).unsqueeze(1)
        optimizer.zero_grad()
        outputs = model_pt(images)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        total_loss += loss.item()
    print(f"Epoch {epoch+1}: Train Loss = {total_loss / len(train_loader):.4f}")

# Evaluation
model_pt.eval()
correct = 0
total = 0
with torch.no_grad():
    for images, labels in val_loader:
        images, labels = images.to(device), labels.to(device).unsqueeze(1)
        outputs = model_pt(images)
        preds = (outputs > 0.5).int()
        correct += (preds == labels.int()).sum().item()
        total += labels.size(0)

pt_accuracy = 100 * correct / total
print(f"‚úÖ PyTorch Accuracy: {pt_accuracy:.2f}%")

def predict_tf(image_path):
    img = tf.io.read_file(image_path)
    img = tf.image.decode_jpeg(img, channels=3)
    img = tf.image.resize(img, (150, 150))
    img = img / 255.0
    img = tf.expand_dims(img, 0)  # Add batch dimension

    prediction = model_tf.predict(img)[0][0]
    label = "Dog" if prediction > 0.5 else "Cat"
    print(f"üê∂ TensorFlow Prediction: {label} (Confidence: {prediction:.2f})")
    from torchvision import transforms
from PIL import Image

# Reuse the same transform used for training
transform = transforms.Compose([
    transforms.Resize((150, 150)),
    transforms.ToTensor()
])

def predict_pt(image_path):
    model_pt.eval()
    img = Image.open(image_path).convert("RGB")
    img = transform(img).unsqueeze(0).to(device)

    with torch.no_grad():
        output = model_pt(img)
        pred = (output > 0.5).int().item()

    label = "Dog" if pred == 1 else "Cat"
    print(f"üê± PyTorch Prediction: {label} (Confidence: {output.item():.2f})")
test_image_path = "WhatsApp Image 2025-05-27 at 7.00.38 PM (1).jpeg"

predict_tf(test_image_path)
predict_pt(test_image_path)

from google.colab import files
uploaded = files.upload()  # Choose your JPG or PNG image